/**
 * Service Worker Registration com Workbox
 * Features: Update detection, skip waiting control, cache management
 */

export class ServiceWorkerManager {
	constructor() {
		this.registration = null;
		this.updateAvailable = false;
		this.callbacks = {
			updateAvailable: [],
			controllerChanged: [],
			error: []
		};
	}

	// Registrar service worker
	async register() {
		if (!('serviceWorker' in navigator)) {
			console.warn('[SW] Service Workers n√£o suportados neste navegador');
			return null;
		}

		try {
			// Aguarda carregamento completo para n√£o afetar performance inicial
			if (document.readyState === 'loading') {
				await new Promise(resolve => {
					document.addEventListener('DOMContentLoaded', resolve);
				});
			}

			// Delay adicional para n√£o competir com recursos cr√≠ticos
			await new Promise(resolve => setTimeout(resolve, 1000));

			console.log('[SW] Registrando service worker...');

			this.registration = await navigator.serviceWorker.register('/sw.js', {
				scope: '/',
				type: 'module', // Necess√°rio para imports ES6
				updateViaCache: 'none' // For√ßa verifica√ß√£o de updates
			});

			console.log('[SW] ‚úÖ Service worker registrado');

			// Setup de event listeners
			this.setupEventListeners();

			// Verifica por updates imediatamente ap√≥s registro
			this.checkForUpdates();

			// Verifica por updates periodicamente (a cada 30 minutos)
			setInterval(() => this.checkForUpdates(), 30 * 60 * 1000);

			return this.registration;

		} catch (error) {
			console.error('[SW] ‚ùå Erro ao registrar service worker:', error);
			// Migra√ß√£o: se houver SW cl√°ssico antigo registrado, desinstalar e tentar novamente como m√≥dulo
			const msg = String(error?.message || '');
			const isClassicVsModuleMismatch = /import statement outside a module/i.test(msg) || /Unexpected token 'import'/.test(msg);
			if (isClassicVsModuleMismatch) {
				try {
					const regs = await navigator.serviceWorker.getRegistrations();
					for (const reg of regs) {
						await reg.unregister();
					}
					// Pequeno atraso para garantir libera√ß√£o
					await new Promise(r => setTimeout(r, 300));
					console.warn('[SW] Realizando migra√ß√£o de classic -> module. Tentando novo registro...');
					this.registration = await navigator.serviceWorker.register('/sw.js', {
						scope: '/',
						type: 'module',
						updateViaCache: 'none'
					});
					console.log('[SW] ‚úÖ Re-registro bem-sucedido ap√≥s migra√ß√£o');
					this.setupEventListeners();
					this.checkForUpdates();
					return this.registration;
				} catch (re) {
					console.error('[SW] Falha ao migrar SW:', re);
				}
			}

			this.triggerCallback('error', error);
			return null;
		}
	}

	// Setup de event listeners
	setupEventListeners() {
		if (!this.registration) return;

		// Novo service worker instalando
			this.registration.addEventListener('updatefound', () => {
				const newWorker = this.registration.installing;
				if (!newWorker) return;

				newWorker.addEventListener('statechange', async () => {
					if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
						console.log('[SW] üÜï Nova vers√£o dispon√≠vel');
						this.updateAvailable = true;
						this.triggerCallback('updateAvailable', newWorker);
						// Auto-aplicar update para evitar assets 404 por index antigo
						try {
							await this.applyUpdate();
							console.log('[SW] ‚è≠Ô∏è  SKIP_WAITING enviado');
						} catch (e) {
							console.warn('[SW] Falha ao aplicar update automaticamente:', e);
						}
					}
				});
			});

		// Controller mudou (nova vers√£o ativa)
		navigator.serviceWorker.addEventListener('controllerchange', () => {
			console.log('[SW] üîÑ Controller alterado - aplicando nova vers√£o');
			this.triggerCallback('controllerChanged');
			// Recarregar ap√≥s pequena espera para garantir ativa√ß√£o completa
			setTimeout(() => {
				try { window.location.reload(); } catch(_) {}
			}, 300);
		});

		// Messages do service worker
		navigator.serviceWorker.addEventListener('message', (event) => {
			console.log('[SW] üí¨ Mensagem recebida:', event.data);

			if (event.data?.type === 'CACHE_UPDATED') {
				// Cache foi atualizado em background
				this.triggerCallback('cacheUpdated', event.data);
			}
		});
	}

	// Verificar manualmente por updates
	async checkForUpdates() {
		if (!this.registration) return;

		try {
			await this.registration.update();
		} catch (error) {
			console.warn('[SW] Erro ao verificar updates:', error);
		}
	}

	// Aplicar update (skip waiting)
	async applyUpdate() {
		if (!this.registration || !this.registration.waiting) {
			console.warn('[SW] Nenhum update pendente');
			return;
		}

		// Enviar mensagem para o SW waiting aplicar update
		this.registration.waiting.postMessage({ type: 'SKIP_WAITING' });
	}

	// Registrar callbacks para eventos
	on(event, callback) {
		if (this.callbacks[event]) {
			this.callbacks[event].push(callback);
		}
	}

	// Disparar callbacks
	triggerCallback(event, data) {
		if (this.callbacks[event]) {
			this.callbacks[event].forEach(callback => callback(data));
		}
	}

	// Limpar caches antigos manualmente
	async clearOldCaches() {
		if (!('caches' in window)) return;

		try {
			const cacheNames = await caches.keys();
			const currentVersion = 'workbox-v2.0.0';

			const oldCaches = cacheNames.filter(name => !name.includes(currentVersion));

			await Promise.all(oldCaches.map(name => {
				console.log(`[SW] üßπ Removendo cache antigo: ${name}`);
				return caches.delete(name);
			}));

			console.log(`[SW] ‚úÖ ${oldCaches.length} caches antigos removidos`);

		} catch (error) {
			console.error('[SW] Erro ao limpar caches:', error);
		}
	}

	// Obter estat√≠sticas de cache
	async getCacheStats() {
		if (!('caches' in window)) return null;

		try {
			const cacheNames = await caches.keys();
			const stats = {};

			for (const name of cacheNames) {
				const cache = await caches.open(name);
				const keys = await cache.keys();
				stats[name] = {
					entries: keys.length,
					urls: keys.map(req => req.url)
				};
			}

			return stats;
		} catch (error) {
			console.error('[SW] Erro ao obter stats de cache:', error);
			return null;
		}
	}
}

// Inst√¢ncia singleton
export const swManager = new ServiceWorkerManager();

// Auto-inicializa√ß√£o quando m√≥dulo √© importado - TEMPORARIAMENTE DESABILITADO
// Aguardando corre√ß√£o do deployment do service worker no Vercel
// if (typeof window !== 'undefined' && import.meta.env.PROD) {
//	swManager.register();
// }

// Export para uso direto
export default swManager;
